# API Provider 增强功能实现指南

## 📋 概述

本文档提供API Provider功能的增强实现指南，包括搜索过滤、批量操作、测试连接、动画优化等功能的详细实现方案。

## 🔍 1. 搜索和过滤功能

### 1.1 需求说明

- 按名称搜索Provider
- 按状态过滤（全部/启用/禁用）
- 按开放类型过滤（全部/公开/私有）
- 实时搜索，无需点击按钮

### 1.2 实现方案

#### 步骤1: 添加状态管理

在 `APIConfig.tsx` 中添加搜索和过滤状态：

```typescript
// 搜索和过滤状态
const [searchKeyword, setSearchKeyword] = useState('');
const [statusFilter, setStatusFilter] = useState<number | 'all'>('all');
const [openTypeFilter, setOpenTypeFilter] = useState<number | 'all'>('all');
```

#### 步骤2: 实现过滤逻辑

```typescript
/**
 * 过滤Provider列表
 */
const getFilteredProviders = (): APIProvider[] => {
  return providers.filter((provider) => {
    // 关键词搜索（名称、URL、模型）
    const keyword = searchKeyword.toLowerCase();
    const matchesKeyword = !keyword || 
      provider.name.toLowerCase().includes(keyword) ||
      provider.api_url.toLowerCase().includes(keyword) ||
      provider.api_model.toLowerCase().includes(keyword) ||
      (provider.api_remark && provider.api_remark.toLowerCase().includes(keyword));

    // 状态过滤
    const matchesStatus = statusFilter === 'all' || 
      provider.api_status === statusFilter;

    // 开放类型过滤
    const matchesOpenType = openTypeFilter === 'all' || 
      provider.api_open === openTypeFilter;

    return matchesKeyword && matchesStatus && matchesOpenType;
  });
};
```

#### 步骤3: 添加搜索栏UI

在页面头部和表格之间插入：

```typescript
{/* 搜索和过滤栏 */}
<div className="search-filter-bar">
  <div className="search-box">
    <span className="search-icon">🔍</span>
    <input
      type="text"
      placeholder="搜索名称、URL或模型..."
      value={searchKeyword}
      onChange={(e) => setSearchKeyword(e.target.value)}
      className="search-input"
    />
    {searchKeyword && (
      <button 
        className="clear-btn" 
        onClick={() => setSearchKeyword('')}
      >
        ✕
      </button>
    )}
  </div>

  <div className="filter-controls">
    <select
      value={statusFilter}
      onChange={(e) => setStatusFilter(
        e.target.value === 'all' ? 'all' : parseInt(e.target.value)
      )}
      className="filter-select"
    >
      <option value="all">全部状态</option>
      <option value="1">仅启用</option>
      <option value="0">仅禁用</option>
    </select>

    <select
      value={openTypeFilter}
      onChange={(e) => setOpenTypeFilter(
        e.target.value === 'all' ? 'all' : parseInt(e.target.value)
      )}
      className="filter-select"
    >
      <option value="all">全部类型</option>
      <option value="1">仅公开</option>
      <option value="0">仅私有</option>
    </select>
  </div>
</div>
```

#### 步骤4: 更新渲染逻辑

将表格渲染中的 `providers` 替换为 `getFilteredProviders()`:

```typescript
{getFilteredProviders().map((provider) => (
  <tr key={provider.id}>
    {/* ... 表格内容 ... */}
  </tr>
))}
```

#### 步骤5: 添加CSS样式

在 `apiconfig.css` 中添加：

```css
/* 搜索过滤栏 */
.search-filter-bar {
  display: flex;
  gap: 1rem;
  align-items: center;
  background: white;
  padding: 1.5rem;
  border-radius: 12px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin-bottom: 1.5rem;
}

.search-box {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  background: #f7fafc;
  padding: 0.75rem 1rem;
  border-radius: 8px;
  border: 2px solid transparent;
  transition: all 0.2s;
}

.search-box:focus-within {
  border-color: #667eea;
  background: white;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.search-icon {
  font-size: 1.2rem;
  color: #718096;
}

.search-input {
  flex: 1;
  border: none;
  background: transparent;
  font-size: 1rem;
  outline: none;
  color: #2d3748;
}

.search-input::placeholder {
  color: #a0aec0;
}

.clear-btn {
  padding: 0.25rem 0.5rem;
  background: transparent;
  border: none;
  color: #a0aec0;
  cursor: pointer;
  font-size: 1.2rem;
  transition: color 0.2s;
}

.clear-btn:hover {
  color: #718096;
}

.filter-controls {
  display: flex;
  gap: 0.75rem;
}

.filter-select {
  padding: 0.75rem 1rem;
  border: 2px solid #e2e8f0;
  border-radius: 8px;
  background: white;
  font-size: 0.95rem;
  color: #2d3748;
  cursor: pointer;
  transition: all 0.2s;
  outline: none;
}

.filter-select:hover {
  border-color: #cbd5e0;
}

.filter-select:focus {
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* 响应式 */
@media (max-width: 768px) {
  .search-filter-bar {
    flex-direction: column;
  }

  .search-box {
    width: 100%;
  }

  .filter-controls {
    width: 100%;
  }

  .filter-select {
    flex: 1;
  }
}
```

### 1.3 显示搜索结果统计

```typescript
{/* 搜索结果提示 */}
{!loading && !error && (
  <div className="search-result-info">
    {searchKeyword || statusFilter !== 'all' || openTypeFilter !== 'all' ? (
      <p>
        找到 <strong>{getFilteredProviders().length}</strong> 个匹配的Provider
        {searchKeyword && ` (关键词: "${searchKeyword}")`}
      </p>
    ) : (
      <p>共 <strong>{providers.length}</strong> 个Provider</p>
    )}
  </div>
)}
```

CSS样式：

```css
.search-result-info {
  padding: 0.75rem 1.5rem;
  background: #edf2f7;
  border-radius: 8px;
  margin-bottom: 1rem;
  font-size: 0.9rem;
  color: #4a5568;
}

.search-result-info strong {
  color: #667eea;
  font-weight: 600;
}
```

---

## 📦 2. 批量操作功能

### 2.1 需求说明

- 批量选择Provider
- 批量启用/禁用
- 批量删除
- 全选/取消全选

### 2.2 实现方案

#### 步骤1: 添加选择状态

```typescript
// 批量操作状态
const [selectedIds, setSelectedIds] = useState<number[]>([]);
const [showBatchActions, setShowBatchActions] = useState(false);
```

#### 步骤2: 选择逻辑

```typescript
/**
 * 切换单个Provider选中状态
 */
const toggleSelect = (id: number) => {
  setSelectedIds(prev => 
    prev.includes(id) 
      ? prev.filter(i => i !== id)
      : [...prev, id]
  );
};

/**
 * 全选/取消全选
 */
const toggleSelectAll = () => {
  const filteredProviders = getFilteredProviders();
  if (selectedIds.length === filteredProviders.length) {
    setSelectedIds([]);
  } else {
    setSelectedIds(filteredProviders.map(p => p.id));
  }
};

/**
 * 批量启用
 */
const batchEnable = async () => {
  try {
    await Promise.all(
      selectedIds.map(id => 
        APIProviderService.update(id, { api_status: 1 })
      )
    );
    await loadProviders();
    setSelectedIds([]);
    setToast({ message: `已启用 ${selectedIds.length} 个Provider`, type: 'success' });
  } catch (err: any) {
    setToast({ message: err.message || '批量操作失败', type: 'error' });
  }
};

/**
 * 批量禁用
 */
const batchDisable = async () => {
  try {
    await Promise.all(
      selectedIds.map(id => 
        APIProviderService.update(id, { api_status: 0 })
      )
    );
    await loadProviders();
    setSelectedIds([]);
    setToast({ message: `已禁用 ${selectedIds.length} 个Provider`, type: 'success' });
  } catch (err: any) {
    setToast({ message: err.message || '批量操作失败', type: 'error' });
  }
};

/**
 * 批量删除
 */
const batchDelete = async () => {
  if (!window.confirm(`确定要删除 ${selectedIds.length} 个Provider吗？`)) {
    return;
  }

  try {
    await Promise.all(
      selectedIds.map(id => APIProviderService.delete(id))
    );
    await loadProviders();
    setSelectedIds([]);
    setToast({ message: `已删除 ${selectedIds.length} 个Provider`, type: 'success' });
  } catch (err: any) {
    setToast({ message: err.message || '批量删除失败', type: 'error' });
  }
};
```

#### 步骤3: 添加批量操作栏UI

```typescript
{/* 批量操作栏 */}
{selectedIds.length > 0 && (
  <div className="batch-actions-bar">
    <div className="batch-info">
      <input
        type="checkbox"
        checked={selectedIds.length === getFilteredProviders().length}
        onChange={toggleSelectAll}
        className="batch-checkbox"
      />
      <span>已选择 <strong>{selectedIds.length}</strong> 项</span>
    </div>
    <div className="batch-buttons">
      <button className="btn btn-success" onClick={batchEnable}>
        ✓ 批量启用
      </button>
      <button className="btn btn-warning" onClick={batchDisable}>
        ✗ 批量禁用
      </button>
      <button className="btn btn-danger" onClick={batchDelete}>
        🗑️ 批量删除
      </button>
      <button 
        className="btn btn-secondary" 
        onClick={() => setSelectedIds([])}
      >
        取消选择
      </button>
    </div>
  </div>
)}
```

#### 步骤4: 添加表格复选框

在表格第一列添加复选框：

```typescript
<thead>
  <tr>
    <th style={{ width: '50px' }}>
      <input
        type="checkbox"
        checked={
          getFilteredProviders().length > 0 &&
          selectedIds.length === getFilteredProviders().length
        }
        onChange={toggleSelectAll}
        className="table-checkbox"
      />
    </th>
    <th>名称</th>
    {/* ...其他列... */}
  </tr>
</thead>

<tbody>
  {getFilteredProviders().map((provider) => (
    <tr 
      key={provider.id}
      className={selectedIds.includes(provider.id) ? 'selected' : ''}
    >
      <td>
        <input
          type="checkbox"
          checked={selectedIds.includes(provider.id)}
          onChange={() => toggleSelect(provider.id)}
          className="table-checkbox"
        />
      </td>
      {/* ...其他列... */}
    </tr>
  ))}
</tbody>
```

#### 步骤5: 添加CSS样式

```css
/* 批量操作栏 */
.batch-actions-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #667eea;
  color: white;
  padding: 1rem 1.5rem;
  border-radius: 12px;
  margin-bottom: 1rem;
  box-shadow: 0 4px 6px rgba(102, 126, 234, 0.3);
}

.batch-info {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-size: 1rem;
}

.batch-info strong {
  font-weight: 700;
  font-size: 1.1rem;
}

.batch-buttons {
  display: flex;
  gap: 0.75rem;
}

.batch-buttons .btn {
  padding: 0.6rem 1.2rem;
  font-size: 0.9rem;
}

.btn-success {
  background: #48bb78;
  color: white;
}

.btn-success:hover {
  background: #38a169;
}

.btn-warning {
  background: #ed8936;
  color: white;
}

.btn-warning:hover {
  background: #dd6b20;
}

.btn-danger {
  background: #f56565;
  color: white;
}

.btn-danger:hover {
  background: #e53e3e;
}

/* 复选框样式 */
.table-checkbox,
.batch-checkbox {
  width: 18px;
  height: 18px;
  cursor: pointer;
  accent-color: #667eea;
}

/* 选中行高亮 */
.provider-table tbody tr.selected {
  background-color: #edf2f7;
  border-left: 3px solid #667eea;
}

/* 响应式 */
@media (max-width: 768px) {
  .batch-actions-bar {
    flex-direction: column;
    gap: 1rem;
  }

  .batch-buttons {
    width: 100%;
    flex-wrap: wrap;
  }

  .batch-buttons .btn {
    flex: 1;
    min-width: 120px;
  }
}
```

---

## 🧪 3. Provider连接测试功能

### 3.1 需求说明

- 测试Provider配置是否正确
- 验证API密钥有效性
- 显示测试结果

### 3.2 实现方案

#### 步骤1: 添加测试状态

```typescript
const [testingId, setTestingId] = useState<number | null>(null);
```

#### 步骤2: 实现测试逻辑

```typescript
/**
 * 测试Provider连接
 */
const testConnection = async (provider: APIProvider) => {
  setTestingId(provider.id);
  
  try {
    // 模拟API测试（实际应调用后端测试接口）
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // 这里应该调用实际的测试接口
    // const result = await APIProviderService.test(provider.id);
    
    setToast({
      message: `Provider "${provider.name}" 连接成功`,
      type: 'success',
    });
  } catch (err: any) {
    setToast({
      message: `连接失败: ${err.message}`,
      type: 'error',
    });
  } finally {
    setTestingId(null);
  }
};
```

#### 步骤3: 添加测试按钮

在操作列添加测试按钮：

```typescript
<td>
  <div className="action-buttons">
    <button
      className="btn-icon btn-test"
      onClick={() => testConnection(provider)}
      disabled={testingId === provider.id}
      title="测试连接"
    >
      {testingId === provider.id ? '⏳' : '🔌'}
    </button>
    <button
      className="btn-icon btn-edit"
      onClick={() => handleEdit(provider)}
      title="编辑"
    >
      ✏️
    </button>
    <button
      className="btn-icon btn-delete"
      onClick={() => handleDelete(provider.id, provider.name)}
      title="删除"
    >
      🗑️
    </button>
  </div>
</td>
```

#### 步骤4: 添加CSS样式

```css
.btn-icon.btn-test {
  color: #48bb78;
}

.btn-icon.btn-test:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
```

### 3.3 后端测试接口（建议）

在后端添加测试接口：

```go
// backend/api/handlers/api_provider_handler.go

// TestAPIProviderHandler 测试API Provider连接
func TestAPIProviderHandler(c *gin.Context) {
    userMobile, _ := c.Get("mobile")
    idStr := c.Param("id")
    id, _ := strconv.ParseUint(idStr, 10, 64)

    // 获取Provider配置
    provider, err := services.GetAPIProvider(userMobile.(string), uint(id))
    if err != nil {
        utils.ResponseError(&ctx, c, utils.CodeServerBusy, "获取Provider失败")
        return
    }

    // 解密API Key
    apiKey, err := services.GetDecryptedAPIKey(provider)
    if err != nil {
        utils.ResponseError(&ctx, c, utils.CodeServerBusy, "解密API Key失败")
        return
    }

    // 测试API连接（简单的HTTP请求测试）
    client := &http.Client{Timeout: 10 * time.Second}
    req, _ := http.NewRequest("GET", provider.APIURL, nil)
    req.Header.Set("Authorization", "Bearer "+apiKey)
    
    resp, err := client.Do(req)
    if err != nil {
        utils.ResponseError(&ctx, c, utils.CodeServerBusy, "连接失败: "+err.Error())
        return
    }
    defer resp.Body.Close()

    if resp.StatusCode == 200 || resp.StatusCode == 401 {
        // 200或401都说明服务器可达
        utils.ResponseSuccess(&ctx, c, gin.H{
            "status": "connected",
            "message": "连接成功",
        })
    } else {
        utils.ResponseError(&ctx, c, utils.CodeServerBusy, 
            fmt.Sprintf("连接失败，状态码: %d", resp.StatusCode))
    }
}
```

---

## 🎨 4. 动画优化

### 4.1 需求说明

- 页面加载动画
- 表格行hover效果
- 按钮点击反馈
- 过渡动画

### 4.2 实现方案

在 `apiconfig.css` 中添加动画：

```css
/* 页面淡入动画 */
.api-config-page {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* 表格行动画 */
.provider-table tbody tr {
  transition: all 0.2s ease;
}

.provider-table tbody tr:hover {
  transform: translateX(4px);
  box-shadow: -4px 0 0 #667eea;
}

/* 卡片弹出动画 */
.modal-content {
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(50px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* 按钮点击效果 */
.btn {
  position: relative;
  overflow: hidden;
  transition: all 0.2s;
}

.btn:active {
  transform: scale(0.95);
}

.btn::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

.btn:active::after {
  width: 300px;
  height: 300px;
}

/* 状态标签切换动画 */
.status-badge,
.open-badge {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.status-badge:active,
.open-badge:active {
  transform: scale(0.9);
}

/* 加载动画优化 */
.loading-spinner {
  animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* 搜索框聚焦动画 */
.search-box {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.search-box:focus-within {
  transform: translateY(-2px);
}

/* Toast消息滑入动画 */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* 删除行淡出动画 */
@keyframes fadeOut {
  from {
    opacity: 1;
    max-height: 100px;
  }
  to {
    opacity: 0;
    max-height: 0;
    padding: 0;
    margin: 0;
  }
}

.provider-table tbody tr.deleting {
  animation: fadeOut 0.3s ease-out forwards;
}
```

### 4.3 添加骨架屏

```typescript
// 加载骨架屏组件
const LoadingSkeleton = () => (
  <div className="skeleton-container">
    {[1, 2, 3, 4, 5].map((i) => (
      <div key={i} className="skeleton-row">
        <div className="skeleton-cell skeleton-shimmer" />
        <div className="skeleton-cell skeleton-shimmer" />
        <div className="skeleton-cell skeleton-shimmer" />
      </div>
    ))}
  </div>
);
```

CSS:

```css
.skeleton-container {
  background: white;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.skeleton-row {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
}

.skeleton-cell {
  height: 40px;
  background: #e2e8f0;
  border-radius: 8px;
  flex: 1;
}

.skeleton-shimmer {
  background: linear-gradient(
    90deg,
    #e2e8f0 0%,
    #edf2f7 50%,
    #e2e8f0 100%
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}
```

---

## 💾 5. 本地缓存策略

### 5.1 需求说明

- 缓存Provider列表
- 减少不必要的API调用
- 自动刷新策略

### 5.2 实现方案

```typescript
// 缓存键
const CACHE_KEY = 'api_providers_cache';
const CACHE_EXPIRY_KEY = 'api_providers_cache_expiry';
const CACHE_DURATION = 5 * 60 * 1000; // 5分钟

/**
 * 从缓存加载数据
 */
const loadFromCache = (): APIProvider[] | null => {
  try {
    const cached = localStorage.getItem(CACHE_KEY);
    const expiry = localStorage.getItem(CACHE_EXPIRY_KEY);
    
    if (!cached || !expiry) {
      return null;
    }

    const expiryTime = parseInt(expiry, 10);
    if (Date.now() > expiryTime) {
      // 缓存过期
      localStorage.removeItem(CACHE_KEY);
      localStorage.removeItem(CACHE_EXPIRY_KEY);
      return null;
    }

    return JSON.parse(cached);
  } catch (error) {
    console.error('Failed to load cache:', error);
    return null;
  }
};

/**
 * 保存到缓存
 */
const saveToCache = (data: APIProvider[]) => {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(data));
    localStorage.setItem(
      CACHE_EXPIRY_KEY,
      (Date.now() + CACHE_DURATION).toString()
    );
  } catch (error) {
    console.error('Failed to save cache:', error);
  }
};

/**
 * 清除缓存
 */
const clearCache = () => {
  localStorage.removeItem(CACHE_KEY);
  localStorage.removeItem(CACHE_EXPIRY_KEY);
};

/**
 * 加载Provider列表（带缓存）
 */
const loadProviders = async (forceRefresh = false) => {
  // 尝试从缓存加载
  if (!forceRefresh) {
    const cached = loadFromCache();
    if (cached) {
      setProviders(cached);
      setLoading(false);
      return;
    }
  }

  setLoading(true);
  setError(null);

  try {
    const result = await APIProviderService.list();
    const data = result.list || [];
    setProviders(data);
    saveToCache(data); // 保存到缓存
  } catch (err: any) {
    setError(err.message || '加载 API Provider 列表失败');
  } finally {
    setLoading(false);
  }
};
```

### 5.3 添加手动刷新按钮

```typescript
<button 
  className="btn btn-secondary" 
  onClick={() => loadProviders(true)}
  title="刷新列表"
>
  🔄 刷新
</button>
```

---

## 📊 6. 实现优先级建议

根据实用性和开发难度，建议按以下顺序实现：

| 优先级 | 功能 | 开发难度 | 用户价值 | 预计时间 |
|--------|------|---------|---------|---------|
| ⭐⭐⭐ | 搜索和过滤 | 低 | 高 | 2小时 |
| ⭐⭐⭐ | 动画优化 | 低 | 中 | 1小时 |
| ⭐⭐ | 批量操作 | 中 | 中 | 3小时 |
| ⭐⭐ | 本地缓存 | 低 | 中 | 1小时 |
| ⭐ | 连接测试 | 高 | 中 | 4小时（含后端）|

## 🎯 总结

本指南提供了5个核心增强功能的详细实现方案：

1. **搜索和过滤** - 提升查找效率
2. **批量操作** - 提高管理效率
3. **连接测试** - 验证配置正确性
4. **动画优化** - 提升用户体验
5. **本地缓存** - 减少API调用，提升性能

所有功能都经过精心设计，确保：
- ✅ 代码简洁易维护
- ✅ UI/UX友好
- ✅ 性能优秀
- ✅ 响应式设计
- ✅ 渐进增强

开发者可以根据实际需求选择性实现这些功能。每个功能都是独立的，可以单独添加而不影响现有功能。
